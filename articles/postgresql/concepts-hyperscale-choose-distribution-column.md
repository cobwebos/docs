---
title: 在 Azure 数据库中为 PostgreSQL – 超大规模 (Citus) （预览版） 选择分布列
description: 在超大规模的常见情形的分布列的很好的选择
author: jonels-msft
ms.author: jonels
ms.service: postgresql
ms.subservice: hyperscale-citus
ms.topic: conceptual
ms.date: 05/06/2019
ms.openlocfilehash: e9fba14b8979f739fd29bc277e32fb544221d08a
ms.sourcegitcommit: d4dfbc34a1f03488e1b7bc5e711a11b72c717ada
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 06/13/2019
ms.locfileid: "65078980"
---
# <a name="choose-distribution-columns-in-azure-database-for-postgresql--hyperscale-citus-preview"></a>在 Azure 数据库中为 PostgreSQL – 超大规模 (Citus) （预览版） 选择分布列

选择每个表的分布列是**最重要的一个**建模决策。 超大规模存储在基于行的分布列的值的分片中的行。

正确的选择组相关数据一起进行在相同物理节点上查询的所有 SQL 功能快速和添加支持。 不正确的选择使系统运行缓慢，并不会在节点上支持所有 SQL 功能。

本部分提供分发列提示针对两个最常见的超大规模方案。

### <a name="multi-tenant-apps"></a>多租户应用

多租户体系结构使用一种形式的分层数据库建模以将查询分配到服务器组中的节点。  数据层次结构的顶部称为*租户 ID*，并且需要存储在每个表的列。

超大规模进行检查以查看哪个租户 ID，它们涉及，并找到匹配表分片的查询。 它将查询路由到一个包含分片的单个辅助角色节点。 包含所有相关数据放置在同一节点上运行的查询称为共置。

下图说明了多租户数据模型中的共置。 它包含两个表，客户和市场活动，每个分布的`account_id`。 带阴影的框表示的分片，其颜色的每个表示哪个辅助角色节点包含它。 上一个辅助角色节点，然后在另一台蓝色，绿色分片存储在一起。 请注意如何客户和市场活动之间的 join 查询将具有所需的所有数据一起在一个节点上时将这两个表限制为同一帐户\_id。

![多租户共置](media/concepts-hyperscale-choosing-distribution-column/multi-tenant-colocation.png)

若要应用此设计自己的架构中，标识由什么构成你的应用程序中的租户。 常见的实例包含公司、 帐户、 组织或客户。 列名称将类似于`company_id`或`customer_id`。 检查每个查询，并问问自己： 将工作如果有其他的 WHERE 子句，可以将所涉及的所有表都限制为具有相同的租户 ID 的行？
多租户模型中的查询的作用域为一个租户，例如在特定存储将范围上销售量或库存查询。

#### <a name="best-practices"></a>最佳实践

-   **分区分布表通过常见租户\_id 列。** 例如，在租户所在的公司，租户的 SaaS 应用程序\_id 可能是公司\_id。
-   **将小跨租户表转换为引用表。** 当多个租户共享信息的小型表时，引用表的形式分发。
-   **将租户的所有应用程序查询的筛选器限制\_id。** 每个查询应请求一次一个租户的信息。

读取[多租户教程](./tutorial-design-database-hyperscale-multi-tenant.md)有关构建此类应用程序的示例。

### <a name="real-time-apps"></a>实时应用程序

多租户体系结构引入了层次结构，并使用数据归置到每个租户的路由查询。 与此相反，实时体系结构依赖于特定分发其数据以实现高度并行处理的属性。

我们使用"实体 ID"作为实时模型中的分布列的一个术语。 典型的实体是用户、 主机或设备。

实时查询通常要求按日期或类别分组的数值聚合。 超大规模将这些查询发送到的部分结果的每个分片，并处理协调器节点上汇集的最终答案。 查询运行速度最快时为多个节点都参与尽可能和没有单一节点必须执行消耗的工作。

#### <a name="best-practices"></a>最佳实践

-   **选择具有较大基数作为分布列的列。** 有关比较，\"状态\"上具有值"new"的订单表字段"付费"和"已发货"是的分布列的选择不当。 该示例假定只有这些几个值，这就限制了可以容纳的数据的分片数和可以对其进行处理的节点数。 在具有较大基数的列，最好此外，若要选择那些通常用在 group by 子句中或作为联接键。
-   **选择具有均匀分布的列。** 如果你将分发上只对某些常见值倾斜的列的表，然后往往堆积在某些分片表中的数据。 保存这些分片的节点将最终完成比其他节点的更多工作。
-   **常见的列上的事实数据表和维度表进行分布。**
    事实数据表可以具有只有一个分布键。 在另一个密钥上联接的表不会与事实数据表共置。 选择一个维度归置基于频率联接和联接的行的大小。
-   **到引用表中更改某些维度表。** 如果不能为维度表与事实数据表共置，可以通过将分布到引用表的形式中的节点的所有维度表的副本来提高查询性能。

读取[实时仪表板教程](./tutorial-design-database-hyperscale-realtime.md)有关构建此类应用程序的示例。

### <a name="timeseries-data"></a>时序数据

在时间序列的工作负荷，应用程序查询时存档旧的信息的最新信息。

中建模中超大规模的 timeseries 信息的最常见错误使用时间戳本身作为分布列。 基于时间的哈希分布将分发时间看似随机到不同的分片，而无需在分片中保留的时间范围组合在一起。 通常涉及时间的查询引用的时间范围 （例如是最新的数据），因此这种哈希分布会导致网络开销。

#### <a name="best-practices"></a>最佳实践

-   **不要选择时间戳作为分布列。** 选择一个不同的分布列。 在多租户应用中，使用租户 ID，或在实时应用中使用实体 id。
-   **使用 PostgreSQL 表分区次改为。** 使用表分区，按时间顺序排列的数据的大型表分成多个继承表与每个包含不同的时间范围。  将分发在超大规模的 Postgres 分区的表创建为继承的表的分片。

读取[timeseries 教程](https://aka.ms/hyperscale-tutorial-timeseries)有关构建此类应用程序的示例。

## <a name="next-steps"></a>后续步骤
- 了解如何[共置](concepts-hyperscale-colocation.md)之间分散的数据可帮助快速运行查询
